import React, { useState, useEffect } from "react";
import "./RelativesKhata.css";
import { useNavigate } from "react-router-dom";

import { saveAs } from 'file-saver'; // Import file-saver to handle file downloads

const RelativesKhata = () => {
  const navigate = useNavigate();
  const [date, setDate] = useState(() => {
    const today = new Date();
    const day = String(today.getDate()).padStart(2, "0");
    const month = String(today.getMonth() + 1).padStart(2, "0"); //January is 0!
    const year = today.getFullYear();

    return `${year}-${month}-${day}`;
  });
  const [source, setSource] = useState("");
  const [quantity, setQuantity] = useState("");
  const [amount, setAmount] = useState("");
  const [expenses, setExpenses] = useState([]);
  const [editIndex, setEditIndex] = useState(-1);
  const [showAlert, setShowAlert] = useState(false);
  const [deleteIndex, setDeleteIndex] = useState(null);
  const [groupVisibility, setGroupVisibility] = useState({});
  const [showMonthlySales, setShowMonthlySales] = useState(false);
  const [globalVisibility, setGlobalVisibility] = useState(false);
  const [showModal, setShowModal] = useState(false); // You already have this for controlling the visibility of the modal
  const [modalMessage, setModalMessage] = useState(""); // Add this line to manage the modal message
  const [language, setLanguage] = useState("English");
  const [uniqueNames, setUniqueNames] = useState([]);

  useEffect(() => {
    fetchUniqueNames();
  }, []);

 
  const fetchUniqueNames = async () => {
    try {
      const response = await fetch("http://localhost:3001/unique-namesr");
      const data = await response.json();
      setUniqueNames(data);
    } catch (error) {
      console.error("Error fetching unique names:", error);
    }
  };

  const translations = {
    English: {
      date: "Date",
      name: "Name",
      quantity: "Quantity",
      pricePerKilo: "Price per kilo",
      save: "Save",
      monthlyRelativesSale: "Monthly Relatives Sale",
      overallRelativesSale: "Overall Relatives Sale",
      showAll: "Show All",
      hideAll: "Hide All",
      show: "Show ",
      hide: "Hide ",
      delete: "Delete",
      update: "Update",
      deletePrompt: "Are you sure you want to delete this?",
      yes: "Yes",
      no: "No",
      total: "Total",
      relativeName: "Relative Name",
      enterRelativeName: "Enter Relative Name",
      enterQuantity: "Enter Quantity",
      enterPricePerKilo: "Enter Price per kilo",
      relativesKhata: "Relatives Sales",
      KiloMilk: "Kilo Milk",
      download: "Download Report",
      kaa: "of",
      added: "has been added",
      In: "In",
      expens: "Expense",
      record: "Record has been updated",
    },
    Urdu: {
      date: "تاریخ",
      name: "نام",
      quantity: "مقدار",
      pricePerKilo: "فی کلو قیمت",
      save: "محفوظ کریں",
      monthlyRelativesSale: "ماہانہ رشتہ داروں کی فروخت",
      overallRelativesSale: "کل رشتہ داروں کی فروخت",
      showAll: "سب دیکھیں",
      hideAll: "سب چھپائیں",
      download: "رپورٹ ڈاؤن لوڈ کریں",
      show: "دیکھیں",
      hide: "چھپائیں",
      delete: "حذف کریں",
      update: "اپ ڈیٹ",
      deletePrompt: "کیا آپ واقعی اس  کو حذف کرنا چاہتے ہیں؟",
      yes: "ہاں",
      no: "نہیں",
      relativeName: "رشتہ دار کا نام",
      enterRelativeName: "رشتہ دار کا نام درج کریں",
      enterQuantity: "مقدار درج کریں",
      enterPricePerKilo: "فی کلو قیمت درج کریں",
      relativesKhata: "رشتہ داروں کی فروخت",
      total: "کل",
      KiloMilk: "کلو دودھ",
      kaa: "کا",
      added: " شامل ہوگیا ہے",
      In: "میں",
      record: "ریکارڈ اپ ڈیٹ ہو گیا ہے",
    },
  };
  const monthTranslations = {
    January: "جنوری",
    February: "فروری",
    March: "مارچ",
    April: "اپریل",
    May: "مئی",
    June: "جون",
    July: "جولائی",
    August: "اگست",
    September: "ستمبر",
    October: "اکتوبر",
    November: "نومبر",
    December: "دسمبر",
  };
  const fetchData = async () => {
    try {
      const response = await fetch("http://localhost:3001/relatives");
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      const processedData = data.map((expense) => ({
        ...expense,
        Quantity: parseFloat(expense.Quantity),
        RUnitPrice: parseFloat(expense.RUnitPrice),
        RTotal: expense.RTotal
          ? parseFloat(expense.RTotal).toFixed(2)
          : undefined,
      }));
      setExpenses(processedData);
    } catch (error) {
      console.error("There was an error fetching the sales data:", error);
    }
  };

  useEffect(() => {
    fetchData();
  }, []);


  const generateReport = () => {
    const reportData = expenses.map((expense) => {
      const date = new Date(expense.Date).toLocaleDateString();
      const name = expense.Rname; // Use Rname for relative name
      const quantity = expense.Quantity;
      const unitPrice = expense.RUnitPrice; // Use RUnitPrice for unit price
      const total = expense.RTotal; // Use RTotal for total
  
      return language === "English"
        ? `Date: ${date}, Name: ${name}, Quantity: ${quantity}, Price per kilo: ${unitPrice}, Total: ${total}`
        : `تاریخ: ${date}, نام: ${name}, مقدار: ${quantity}, فی کلو قیمت: ${unitPrice}, کل: ${total}`;
    }).join("\n");
  
    const reportHeader = language === "English"
      ? `${translations[language].relativesKhata}\n\n` // Updated title for RelativesKhata
      : `${translations[language].relativesKhata}\n\n`;
  
    return reportHeader + reportData;
  };
  
  // Handle download report
  const handleDownloadReport = () => {
    const report = generateReport();
    const blob = new Blob([report], { type: "text/plain;charset=utf-8" });
    saveAs(blob, `RelativeSalesReport_${language}.txt`);
  };



  const toggleGroupVisibility = (monthYear) => {
    setGlobalVisibility((prevGlobalState) => {
      if (!prevGlobalState) {
        // If global visibility is off, ensure it stays off and don't toggle individual groups
        console.warn(
          "Global visibility is off. Can't toggle individual group visibility."
        );
        return prevGlobalState;
      }

      // If global visibility is on, toggle the specific month/year group
      setGroupVisibility((prevGroupVisibility) => ({
        ...prevGroupVisibility,
        [monthYear]: !prevGroupVisibility[monthYear],
      }));

      return prevGlobalState; // Return the unchanged global state
    });
  };
  const CustomModal = ({ message, onClose }) => {
    return (
      <div className="custom-modal-overlay">
        <div className="custom-modal">
          <div className="custom-modal-content">
            <p>{message}</p>
            <button onClick={onClose}>Close</button>
          </div>
        </div>
      </div>
    );
  };
  // Group expenses by month and year
  const groupedExpenses = expenses.reduce((acc, expense) => {
    // Ensure the date string is in the correct format (YYYY-MM-DD)
    const expenseDate = expense.Date; // Adjust if the API gives a different property name for the date
    const date = new Date(expenseDate);

    if (isNaN(date.getTime())) {
      console.error("Invalid date for expense:", expense);
      return acc; // Skip this expense if the date is invalid
    }

    const monthYear = `${date.toLocaleString("default", {
      month: "long",
      year: "numeric",
    })}`;
    if (!acc[monthYear]) {
      acc[monthYear] = [];
    }
    acc[monthYear].push(expense);

    return acc;
  }, {});

  const handleSave = async (e) => {
    e.preventDefault();

    const expensePayload = {
      Date: date,
      Rname: source,
      Quantity: parseFloat(quantity),
      RUnitPrice: parseFloat(amount),
    };

    try {
      let response;
      if (editIndex >= 0) {
        // Use the '_id' property of MongoDB instead of 'idRelatives'
        const expenseId = expenses[editIndex]._id; // Adjust to MongoDB _id field
        response = await fetch(`http://localhost:3001/relatives/${expenseId}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(expensePayload),
        });

        // Properly handle the update message with monthYear and updated notice

        const alertMessage = `${translations[language].record}`;

        setModalMessage(alertMessage);
        setShowModal(true);
      } else {
        // Adding a new expense logic
        response = await fetch("http://localhost:3001/relatives", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(expensePayload),
        });

        // Message for a newly added record
        const monthYear = new Date(date).toLocaleString("default", {
          month: "long",
          year: "numeric",
        });
        const alertMessage = `${quantity} ${translations[language].KiloMilk} ${translations[language].added}`;

        setModalMessage(alertMessage);
        setShowModal(true);
      }

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      await fetchData(); // Refresh data after PUT or POST operation

      // Reset form fields and editIndex after successful save
      setSource("");
      setQuantity("");
      setAmount("");
      setEditIndex(-1);
    } catch (error) {
      console.error("There was an error saving the sale:", error);
    }
  };

  const handleDelete = (index) => {
    setShowAlert(true);
    setDeleteIndex(index);
  };

  const handleAlertConfirm = async (isConfirmed) => {
    if (isConfirmed && deleteIndex != null) {
      const expense = expenses[deleteIndex];

      // Check if 'idRelatives' exists in the 'expense' object or log the 'expense' object to verify the field names
      if (expense && expense._id) {
        // Assuming the ID field in MongoDB is '_id'
        try {
          const response = await fetch(
            `http://localhost:3001/relatives/${expense._id}`,
            {
              method: "DELETE",
              headers: {
                "Content-Type": "application/json",
              },
            }
          );

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const result = await response.json();
          console.log(result.message); // Log the message from the backend

          // Refresh the expenses list after deleting an expense
          await fetchData();
        } catch (error) {
          console.error("There was an error deleting the sale:", error);
        }
      } else {
        // Log the expense object to check its structure
        console.error(
          "Attempted to delete an expense without a valid ID",
          expense
        );
      }
    }

    // Reset the state regardless of whether the delete was successful or not
    setDeleteIndex(null);
    setShowAlert(false);
  };

  const getMonthlyExpenses = () => {
    const monthlyExpenses = expenses.reduce((acc, expense) => {
      // Check if the date is valid
      const date = new Date(expense.Date);
      if (isNaN(date.getTime())) {
        console.error("Invalid date for expense:", expense);
        return acc; // Skip this expense if the date is invalid
      }

      const monthYear = `${date.toLocaleString("default", {
        month: "long",
      })} ${date.getFullYear()}`;
      const expenseQuantity = parseFloat(expense.Quantity);
      const expenseUnitPrice = parseFloat(expense.RUnitPrice);
      const monthlyTotal =
        !isNaN(expenseQuantity) && !isNaN(expenseUnitPrice)
          ? expenseQuantity * expenseUnitPrice
          : 0;

      if (!acc[monthYear]) {
        acc[monthYear] = 0;
      }

      acc[monthYear] += monthlyTotal;

      return acc;
    }, {});

    return monthlyExpenses;
  };

  const getOverallExpenses = () => {
    return expenses.reduce((acc, expense) => {
      const expenseQuantity = parseFloat(expense.Quantity);
      const expenseUnitPrice = parseFloat(expense.RUnitPrice);
      const total =
        expenseQuantity && expenseUnitPrice
          ? expenseQuantity * expenseUnitPrice
          : 0;
      return acc + total;
    }, 0);
  };

  const handleUpdate = (index) => {
    const expense = expenses[index];
    setDate(new Date(expense.Date).toISOString().split("T")[0]);
    setSource(expense.Rname); // Corrected: ensure this matches your data structure
    setQuantity(expense.Quantity.toString());
    setAmount(expense.RUnitPrice.toString());
    setEditIndex(index);
  };
  const toggleGlobalVisibility = () => {
    setGlobalVisibility((prevState) => {
      const newState = !prevState;
      // Update all group visibilities based on the new global state
      const newGroupVisibility = Object.keys(groupVisibility).reduce(
        (acc, key) => {
          acc[key] = newState; // Show or hide all based on the new global state
          return acc;
        },
        {}
      );

      setGroupVisibility(newGroupVisibility);
      return newState;
    });
  };

  const toggleMonthlySalesVisibility = () => {
    setShowMonthlySales((prevShow) => !prevShow); // Toggle the visibility state
  };
  return (
    <div className="expenditure-container">
      <button onClick={() => navigate("/")} className="back-arrow">
        &#8592;
      </button>
      <h1 className="expenditure-title">
        {translations[language].relativesKhata}
      </h1>
      <button
        onClick={() =>
          setLanguage((lang) => (lang === "English" ? "Urdu" : "English"))
        }
        className="language-toggle"
      >
        {language === "English" ? "اردو" : "English"}
      </button>
      <form className="expenditure-form" onSubmit={handleSave}>
        <label htmlFor="date" className="expenditure-label">
          {translations[language].date}
        </label>
        <input
          type="date"
          id="date"
          value={date}
          onChange={(e) => setDate(e.target.value)}
          className="expenditure-input date-input"
          required
        />

        <label htmlFor="source" className="expenditure-label">
          {translations[language].name}
        </label>
        <input
          type="text"
          id="source"
          list="consumerNames"
          value={source}
          onChange={(e) => setSource(e.target.value)} // This updates the source when the user types or selects
          className="expenditure-input"
          placeholder="Relative Name"
          required
        />
        <datalist id="consumerNames">
          {uniqueNames.length > 0 ? (
            uniqueNames.map((name, index) => (
              <option key={index} value={name} />
            ))
          ) : (
            <option value="No names available" />
          )}
        </datalist>

        <label htmlFor="quantity" className="expenditure-label">
          {translations[language].quantity}
        </label>
        <input
          type="number"
          id="quantity"
          value={quantity}
          onChange={(e) => setQuantity(e.target.value)}
          className="expenditure-input"
          placeholder={translations[language].enterQuantity}
          required
        />

        <label htmlFor="amount" className="expenditure-label">
          {translations[language].pricePerKilo}
        </label>
        <input
          type="number"
          id="amount"
          value={amount}
          onChange={(e) => setAmount(e.target.value)}
          className="expenditure-input"
          placeholder={translations[language].enterPricePerKilo}
          required
        />

        <button type="submit" className="save-button">
          {translations[language].save}
        </button>
      </form>
      {showModal && (
        <CustomModal
          message={modalMessage}
          onClose={() => setShowModal(false)}
        />
      )}
      <div className="expenses-report">
        <h4>{translations[language].monthlyRelativesSale}</h4>

        <button
          onClick={toggleMonthlySalesVisibility}
          className="toggle-all-button"
        >
          {showMonthlySales
            ? translations[language].hideAll
            : translations[language].showAll}
        </button>

        {showMonthlySales &&
          Object.entries(getMonthlyExpenses()).map(([monthYear, total]) => {
            // Split month and year
            const [month, year] = monthYear.split(" ");

            // Translate the month name if available, otherwise, use the original name
            const translatedMonth =
              language === "Urdu" ? monthTranslations[month] || month : month;

            // Combine translated month and year
            const translatedMonthYear = `${translatedMonth} ${year}`;

            return (
              <div key={monthYear} style={{ color: "green" }}>
                {translations[language].monthlySales} {translatedMonthYear} :{" "}
                {total}
              </div>
            );
          })}

        <h4>
          {translations[language].overallRelativesSale}
          <br />
          <span style={{ color: "green" }}>{getOverallExpenses()}</span>
        </h4>
      </div>
      <button onClick={toggleGlobalVisibility} className="global-toggle-button">
        {globalVisibility
          ? translations[language].hideAll
          : translations[language].showAll}
      </button>


      <button onClick={handleDownloadReport} className="download-button">
        {translations[language].download}
      </button>

      {globalVisibility &&
        Object.entries(groupedExpenses).map(([monthYear, expensesList]) =>
          // Move the statements outside of JSX
          (() => {
            const monthYearArray = monthYear.split(" ");
            const month = monthYearArray[0];
            const year = monthYearArray[1];

            // Translate the month name if the current language is Urdu
            const translatedMonthName =
              language === "Urdu" ? monthTranslations[month] || month : month;

            // Reconstruct the monthYear string with the possibly translated month name
            const displayMonthYear = `${translatedMonthName} ${year}`;

            return (
              <div key={monthYear}>
                <h3 style={{ marginTop: 15 }}>
                  {displayMonthYear}
                  <button
                    onClick={() => toggleGroupVisibility(monthYear)}
                    className="toggle-button"
                  >
                    {groupVisibility[monthYear]
                      ? translations[language].hide
                      : translations[language].show}
                  </button>
                </h3>
                {groupVisibility[monthYear] && (
                  <div className="expenses-display">
                    {expensesList.map((expense, index) => {
                      const actualIndex = expenses.findIndex(
                        (e) => e === expense
                      );
                      const total = expense.quantity * expense.amount;
                      return (
                        <div key={index} className="expense-card">
                          <div>
                            {translations[language].date} :{" "}
                            {new Date(expense.Date).toLocaleDateString()}{" "}
                          </div>
                          <div>
                            {translations[language].name} : {expense.Rname}
                          </div>
                          <div>
                            {translations[language].quantity} :{" "}
                            {expense.Quantity}
                          </div>
                          <div>
                            {translations[language].pricePerKilo} :{" "}
                            {expense.RUnitPrice}
                          </div>
                          <div>
                            {translations[language].total} : {expense.RTotal}
                          </div>
                          <button
                            onClick={() => handleDelete(actualIndex)}
                            className="delete-button1"
                          >
                            {translations[language].delete}{" "}
                          </button>
                          <button
                            onClick={() => handleUpdate(actualIndex)}
                            className="update-button"
                          >
                            {translations[language].update}{" "}
                          </button>
                        </div>
                      );
                    })}
                  </div>
                )}
              </div>
            );
          })()
        )}

      {showAlert && (
        <div className="alert-dialog">
          <p>{translations[language].deletePrompt} </p>
          <button
            onClick={() => handleAlertConfirm(true)}
            className="confirm-yes"
          >
            {translations[language].yes}{" "}
          </button>
          <button
            onClick={() => handleAlertConfirm(false)}
            className="confirm-no"
          >
            {translations[language].no}{" "}
          </button>
        </div>
      )}
    </div>
  );
};

export default RelativesKhata;
